diff u3 D:/Projekte/Triangle/src/newSPLocation.h D:/Projekte/Triangle/new/newSPLocation.h
--- D:/Projekte/Triangle/src/newSPLocation.h	Tue Jun 16 01:43:20 2009
+++ D:/Projekte/Triangle/new/newSPLocation.h	Fri Apr 24 13:13:50 2015
@@ -8,7 +8,7 @@
 // GENERATES PREMIUM QUALITY TRIANGULATIONS; LARGE MINIMUM ANGLE VALUE OR LARGE MINIMUM ANGLE VALUE WHILE HAVING SMALL MAXIMUM ANGLE VALUE.
 
 // for comparing real numbers
-const double compConst = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000001; 
+const double compConst = 1.0e-80;
 
 /// FUNCTION PROTOTYPES
 // TRIANGLE FUNCTIONS
@@ -61,11 +61,14 @@
 int chooseCorrectPoint (REAL x1, REAL y1, REAL x2, REAL y2, REAL x3, REAL y3, int isObtuse );
 void pointBetweenPoints(REAL x1, REAL y1, REAL x2, REAL y2, REAL x, REAL y, REAL *p);
 int testTriangleAngle(struct mesh *m, struct behavior *b, REAL *x1, REAL *y1, REAL *x2, REAL *y2, REAL *x3, REAL *y3 );
+REAL minDistanceToNeigbor(struct mesh *m, struct behavior *b, REAL newlocX, REAL newlocY, struct otri *searchtri);
+#ifndef TRILIBRARY
 void writeparts(struct mesh *m, struct behavior *b, int argc, char **argv);
 REAL returnMinAngle(REAL p1x, REAL p1y,REAL p2x, REAL p2y, REAL p3x, REAL p3y);
 REAL returnMaxAngle(REAL p1x, REAL p1y,REAL p2x, REAL p2y, REAL p3x, REAL p3y);
-REAL minDistanceToNeigbor(struct mesh *m, struct behavior *b, REAL newlocX, REAL newlocY, struct otri *searchtri);
 void detailedHistogram(struct mesh *m, struct behavior *b);
+#endif
+
 /*=====================NEW STEINER POINT FUNCTION============================*/
 /*****************************************************************************/
 /*  Steiner point insertion routine                                          */
@@ -111,7 +114,7 @@
 	REAL shortestEdgeDist, middleEdgeDist, longestEdgeDist;
 	
 	// keeps the vertices according to the angle incident to that vertex in a triangle
-	vertex smallestAngleCorner, middleAngleCorner, largestAngleCorner;
+	vertex smallestAngleCorner = NULL, middleAngleCorner = NULL, largestAngleCorner = NULL;
 	
 	// keeps the type of orientation if the triangle
 	int orientation = 0;
@@ -138,7 +141,6 @@
 	vertex neighborvertex_3;
 	// dummy variables 
   	REAL xi_tmp, eta_tmp;
-	vertex thirdVertex;
 	// for petal intersection
 	REAL vector_x, vector_y, xMidOfLongestEdge, yMidOfLongestEdge, inter_x, inter_y, p[5], voronoiOrInter[4];
 	int isCorrect = -1; 
@@ -721,7 +723,7 @@
 	REAL shortestEdgeDist, middleEdgeDist, longestEdgeDist;
 	
 	// keeps the vertices according to the angle incident to that vertex in a triangle
-	vertex smallestAngleCorner, middleAngleCorner, largestAngleCorner;
+	vertex smallestAngleCorner = NULL, middleAngleCorner = NULL, largestAngleCorner = NULL;
 	
 	// keeps the type of orientation if the triangle
 	int orientation = 0;
@@ -748,7 +750,6 @@
 	vertex neighborvertex_3;
 	// dummy variables 
   	REAL xi_tmp, eta_tmp;
-	vertex thirdVertex;
 	// for petal intersection
 	REAL vector_x, vector_y, xMidOfLongestEdge, yMidOfLongestEdge, inter_x, inter_y, p[5], voronoiOrInter[4];
 	int isCorrect = -1; 
@@ -1153,9 +1154,11 @@
 					line_inter_x = line_p[1];
 					line_inter_y = line_p[2];
 				}else{
-					// for debugging (to make sure)
-					printf("1) No intersection between two lines!!!\n");
-					printf("(%.14f,%.14f) (%.14f,%.14f) (%.14f,%.14f) (%.14f,%.14f)\n",myCircumcenter[0],myCircumcenter[1],vector_x,vector_y,linepnt1_x,linepnt1_y,linepnt2_x,linepnt2_y);
+					if (!b->quiet) {
+					  // for debugging (to make sure)
+					  printf("1) No intersection between two lines!\n");
+					  printf("(%.8f,%.8f) (%.8f,%.8f) (%.8f,%.8f) (%.8f,%.8f)\n",myCircumcenter[0],myCircumcenter[1],vector_x,vector_y,linepnt1_x,linepnt1_y,linepnt2_x,linepnt2_y);
+					}
 				}
 			
 				//---------------------------------------------------------------------//
@@ -1420,9 +1423,11 @@
 					line_inter_x = line_p[1];
 					line_inter_y = line_p[2];
 				}else{
-					// for debugging (to make sure)
-					printf("1) No intersection between two lines!!!\n");
-					printf("(%.14f,%.14f) (%.14f,%.14f) (%.14f,%.14f) (%.14f,%.14f)\n",myCircumcenter[0],myCircumcenter[1],vector_x,vector_y,linepnt1_x,linepnt1_y,linepnt2_x,linepnt2_y);
+					if (!b->quiet) {
+					  // for debugging (to make sure)
+					  printf("2) No intersection between two lines!\n");
+					  printf("(%.8f,%.8f) (%.8f,%.8f) (%.8f,%.8f) (%.8f,%.8f)\n",myCircumcenter[0],myCircumcenter[1],vector_x,vector_y,linepnt1_x,linepnt1_y,linepnt2_x,linepnt2_y);
+					}
 				}		
 				//---------------------------------------------------------------------//
 				/// check if there is a Voronoi vertex between before intersection ///
@@ -1843,22 +1848,21 @@
 		vertex tapex,
 		REAL *newloc){
 
-        int numpoints_p = 0;// keeps the number of points in a star of point p, q, r
+    int numpoints_p = 0;// keeps the number of points in a star of point p, q, r
 	int numpoints_q = 0;
 	int numpoints_r = 0;
-	int i;	
 	REAL possibilities[6];//there can be more than one possibilities
 	int num_pos = 0; // number of possibilities
 	int flag1 = 0, flag2 = 0, flag3 = 0;
 	int newLocFound = 0;
 	
-	REAL points_p[500];// keeps the points in a star of point p, q, r
-	REAL points_q[500];
-	REAL points_r[500];
-
-	vertex v1, v2, v3;	// for ccw test
-	REAL p1[2], p2[2], p3[2];
-	REAL temp[2];
+	REAL *points_p;// keeps the points in a star of point p, q, r
+	REAL *points_q;
+	REAL *points_r;
+
+	points_p = m->acute_mem.points_p;
+	points_q = m->acute_mem.points_q;
+	points_r = m->acute_mem.points_r;
 
 	/*********************** TRY TO RELOCATE POINT "p" *************************/
 
@@ -1883,7 +1887,7 @@
 // 	m->counterclockcount--;
 	// INTERSECTION OF PETALS
 	// first check whether the star angles are appropriate for relocation
-	if(polygonAngles(m,b,numpoints_p,points_p)== 0){
+	if(numpoints_p != 0 && polygonAngles(m,b,numpoints_p,points_p)== 0){
 		//newLocFound = getPetalIntersection(m, b, numpoints_p, points_p, newloc);
 		//newLocFound = getPetalIntersectionBruteForce(m, b,numpoints_p, points_p, newloc,torg[0],torg[1]);
 		if(b->maxangle == 0.0){
@@ -1893,7 +1897,7 @@
 		}
 		//printf("call petal intersection for p\n");
 		// make sure the relocated point is a free vertex	
-		if(newLocFound && numpoints_p != 0 && vertextype(torg) == 2){					
+		if(newLocFound && vertextype(torg) == 2){					
 			possibilities[0] = newloc[0];// something found
 			possibilities[1] = newloc[1];
 			num_pos++;// increase the number of possibilities
@@ -1923,7 +1927,7 @@
 // 	m->counterclockcount--;
 	// INTERSECTION OF PETALS
 	// first check whether the star angles are appropriate for relocation
-	if(polygonAngles(m,b,numpoints_q,points_q)== 0){
+	if(numpoints_q != 0 && polygonAngles(m,b,numpoints_q,points_q)== 0){
 		//newLocFound = getPetalIntersection(m, b,numpoints_q, points_q, newloc);
 		//newLocFound = getPetalIntersectionBruteForce(m, b,numpoints_q, points_q, newloc,tapex[0],tapex[1]);
 		if(b->maxangle == 0.0){
@@ -1934,7 +1938,7 @@
 		//printf("call petal intersection for q\n");	
 	
 		// make sure the relocated point is a free vertex	
-		if(newLocFound && numpoints_q != 0 && vertextype(tdest)==2 ){						
+		if(newLocFound && vertextype(tdest)==2 ){						
 			possibilities[2] = newloc[0];// something found
 			possibilities[3] = newloc[1];
 			num_pos++;// increase the number of possibilities
@@ -1964,7 +1968,7 @@
 // 	m->counterclockcount--;
 	// INTERSECTION OF PETALS
 	// first check whether the star angles are appropriate for relocation
-	if(polygonAngles(m,b,numpoints_r,points_r)== 0){
+	if(numpoints_r != 0 && polygonAngles(m,b,numpoints_r,points_r)== 0){
 		//newLocFound = getPetalIntersection(m, b,numpoints_r, points_r, newloc);
 		//newLocFound = getPetalIntersectionBruteForce(m, b,numpoints_r, points_r, newloc,tdest[0],tdest[1]);
 		if(b->maxangle == 0.0){
@@ -1977,7 +1981,7 @@
 	
 	
 		// make sure the relocated point is a free vertex	
-		if(newLocFound && numpoints_r != 0 && vertextype(tapex) == 2){						
+		if(newLocFound && vertextype(tapex) == 2){						
 			possibilities[4] = newloc[0];// something found
 			possibilities[5] = newloc[1];
 			num_pos++;// increase the number of possibilities
@@ -2011,7 +2015,7 @@
 	else{
 		return 0;// could not find any good relocation
 	}
-	
+	return 0;
 }// end of function doSmoothing()
 //---------------------------------------------------------------------------------//
 // getStarPoints() 
@@ -2109,14 +2113,13 @@
 	int notFound = 0;	// boolean variable if we can find that neighbor or not
 	
 	// for keeping the vertices of the neighbor triangle
-	vertex neighborvertex_1;
-	vertex neighborvertex_2;
-	vertex neighborvertex_3;
+	vertex neighborvertex_1 = NULL;
+	vertex neighborvertex_2 = NULL;
+	vertex neighborvertex_3 = NULL;
 	
 	// used for finding neighbor triangle
 	int firstVertexMatched = 0, secondVertexMatched = 0;	// to find the correct neighbor
 	triangle ptr;             /* Temporary variable used by sym() */
-	int i;	// index variable	
 	/* find neighbors */
 	/* Check each of the triangle's three neighbors to find the correct one */
 	for (badotri.orient = 0; badotri.orient < 3; badotri.orient++) {			
@@ -2238,34 +2241,33 @@
     //REAL compConst = 0.01; // for comparing real numbers
     
     REAL x01, y01;
-    REAL x12, y12;
-    
-    REAL ax, ay, bx, by; //two intersections of two petals disks
+    REAL d01;
     
-    REAL d01, d12;
-    
-    REAL petalx0, petaly0, petalr0, 
-	petalx1, petaly1, petalr1; 
-    
-    REAL p[5];
-    
-    REAL petalx[24];
-    REAL petaly[24];
-    REAL petalr[24];
+    REAL *petalx;
+    REAL *petaly;
+    REAL *petalr;
+    REAL *wedges;
+    REAL *initialConvexPoly;
 
-    REAL wedges[2000];
     REAL xmid, ymid, dist, x3, y3;
     REAL x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, tempx, tempy; 
     REAL ux, uy;
     REAL alpha;
     REAL p1[3];
-    REAL initialConvexPoly[500];
-    REAL poly_points;
     int numpolypoints;
     
-    int numBadTriangle;
+    int i, j;
+	int s, flag, count, num;
 
     REAL petalcenterconstant, petalradiusconstant;
+	
+	acutepool_resize(numpoints, b, &m->acute_mem);
+    
+	petalx = m->acute_mem.petalx;
+    petaly = m->acute_mem.petaly;
+    petalr = m->acute_mem.petalr;
+    wedges = m->acute_mem.wedges;
+	initialConvexPoly = m->acute_mem.initialpoly;
 
     x0 = points[2*numpoints-4];
     y0 = points[2*numpoints-3];
@@ -2282,7 +2284,6 @@
         petalcenterconstant = 0.5 / tan(b->minangle * PI /180.0);
         petalradiusconstant = 0.5 / sin(b->minangle * PI / 180.0);
     }
-    int i, j;
     for(i = 0; i < numpoints*2; i= i+2){
 	x2 = points[i];
 	y2 = points[i+1];
@@ -2406,11 +2407,11 @@
     /// HALF PLANE INTERSECTION: START SPLITTING THE INITIAL POLYGON TO FIND FEASIBLE REGION    
     if(numpoints != 0){
 	// first intersect the opposite located ones
-	int s = (numpoints-1)/2+1;
-	int flag = 0; 
-	int count = 0;
+	s = (numpoints-1)/2+1;
+	flag = 0; 
+	count = 0;
 	i = 1;
-	int num = 8;	
+	num = 8;	
 	for(j = 0; j < 32; j = j+4){
 			numpolypoints = halfPlaneIntersection(num, initialConvexPoly, wedges[32*s+j],wedges[32*s+1+j], wedges[32*s+2+j], wedges[32*s+3+j]);
 			if(numpolypoints == 0)
@@ -2459,6 +2460,11 @@
 	}
    }
    
+   // freeing done by acute memory pool
+	//free(petalx);
+	//free(petaly);
+	//free(petalr);
+	//free(wedges);
 
     return 0;
 }// end of getWedgeIntersectionWithoutMaxAngle()
@@ -2477,36 +2483,39 @@
     //REAL compConst = 0.01; // for comparing real numbers
     
     REAL x01, y01;
-    REAL x12, y12;
-    
-    REAL ax, ay, bx, by; //two intersections of two petals disks
     
-    REAL d01, d12;
+    REAL d01;
     
-    REAL petalx0, petaly0, petalr0, 
-	petalx1, petaly1, petalr1; 
-    
-    REAL p[5];
-    
-    REAL petalx[100];
-    REAL petaly[100];
-    REAL petalr[100];
+    REAL *petalx;
+    REAL *petaly;
+    REAL *petalr;
+    REAL *wedges;
+    REAL *initialConvexPoly;
 
-    REAL wedges[2000];
     REAL xmid, ymid, dist, x3, y3;
     REAL x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4, tempx, tempy,x_5,y_5,x_6,y_6; 
     REAL ux, uy;
     REAL alpha;
     REAL p1[3], p2[3], p3[3], p4[3];
-    REAL initialConvexPoly[500];
-    REAL poly_points;
     int numpolypoints;
     int howManyPoints;	// keeps the number of points used for representing the wedge
     REAL line345 = 4.0, line789 = 4.0; // flag keeping which line to skip or construct
     
     int numBadTriangle;
+    int i, j, k;
+	int s, flag, count, num;
+	int e, n;
+	REAL weight;
 
     REAL petalcenterconstant, petalradiusconstant;
+	
+	acutepool_resize(numpoints, b, &m->acute_mem);
+    
+	petalx = m->acute_mem.petalx;
+    petaly = m->acute_mem.petaly;
+    petalr = m->acute_mem.petalr;
+    wedges = m->acute_mem.wedges;
+	initialConvexPoly = m->acute_mem.initialpoly;
 
     x0 = points[2*numpoints-4];
     y0 = points[2*numpoints-3];
@@ -2523,7 +2532,6 @@
         petalcenterconstant = 0.5 / tan(b->minangle * PI /180.0);
         petalradiusconstant = 0.5 / sin(b->minangle * PI / 180.0);
     }
-    int i, j, k;
     for(i = 0; i < numpoints*2; i= i+2){
 	// minimum angle
     	alpha = b->minangle*PI/180.0;   
@@ -2774,11 +2782,11 @@
     /// HALF PLANE INTERSECTION: START SPLITTING THE INITIAL POLYGON TO FIND FEASIBLE REGION    
     if(numpoints != 0){
 	// first intersect the opposite located ones
-	int s = (numpoints-1)/2+1;
-	int flag = 0; 
-	int count = 0;
+	s = (numpoints-1)/2+1;
+	flag = 0; 
+	count = 0;
 	i = 1;
-	int num = howManyPoints;			
+	num = howManyPoints;			
 	for(j = 0; j < 40; j = j+4){			
 			// in order to skip non-existent lines
 			if(howManyPoints == 4 && (j == 8 || j == 12 || j == 16 || j == 24 || j == 28 || j == 32)){
@@ -2840,9 +2848,8 @@
 			
 			return 1;
 		}
-		int e;
-		int n = (numpoints <= 2) ? 20 : 30;
-		REAL weight;
+
+		n = (numpoints <= 2) ? 20 : 30;
 		// try points other than centroid
 		for(k = 0; k < 2*numpoints; k = k+2){
 			for(e = 1; e < n; e = e + 1){				
@@ -2884,7 +2891,12 @@
 		return 1;
 	}
    }
-   
+
+   // freeing done by acute memory pool
+	//free(petalx);
+	//free(petaly);
+	//free(petalr);
+	//free(wedges);
 
     return 0;
 }// end of getWedgeIntersectionWithMaxAngle()
@@ -2894,7 +2906,7 @@
 // Return 0 if the polygon has angles greater than 2*minangle
 //---------------------------------------------------------------------------------//
 int polygonAngles(struct mesh *m, struct behavior *b,int numpoints, REAL *points){
-	int i,j;
+	int i;
 	for(i = 0; i < numpoints; i++){
 		if(i == numpoints-1){
 			if( testPolygonAngle(m,b, &points[i*2], &points[i*2+1], &points[0], &points[1], &points[2], &points[3]) ){
@@ -3016,15 +3028,20 @@
 	REAL *res = NULL;
 	int count = 0;
  	int intFound = 0;
+	int numpolys;
+
+	polys[0] = (REAL *)malloc(sizeof(REAL) * 100);
+	polys[1] = (REAL *)malloc(sizeof(REAL) * 100);
+
 	dx = x2 - x1;
 	dy = y2 - y1;
-	int numpolys = splitConvexPolygon(numvertices,convexPoly, x1, y1, x2, y2, polys);	
+	numpolys = splitConvexPolygon(numvertices,convexPoly, x1, y1, x2, y2, polys);	
 	if(numpolys == 3){
 		count = numvertices;
 	}else{
 		for (i = 0; i < numpolys; i++) {
-			min = 99999999999999999;
-			max = -99999999999999999;
+			min = 1E+37;
+			max = -1E+37;
 			// compute the minimum and maximum of the
 			// third coordinate of the cross product		
 			for (j = 1; j <= 2*polys[i][0]-1; j = j+2) {				
@@ -3033,7 +3050,7 @@
 				max = (z > max ? z : max);			
 			}
 			// ... and choose the (absolute) greater of both
-			REAL z = (fabs(min) > fabs(max) ? min : max);
+			z = (fabs(min) > fabs(max) ? min : max);
 			// and if it is positive, the polygon polys[i]
 			// is on the left side of line
 			if (z > 0.0) {
@@ -3050,7 +3067,11 @@
 				
 			}
 		}
-	}
+	}
+
+	free(polys[0]);
+	free(polys[1]);
+
 	// update convexPoly
 	return count;
 }// end of halfPlaneIntersection()
@@ -3071,10 +3092,10 @@
 	int state = 0;
 	REAL p[3];
 	// poly1 is constructed in states 0 and 2
-	REAL poly1[100];
+	REAL *poly1 = polys[0];
 	int poly1counter = 0;
 	// poly2 is constructed in state 1
-	REAL poly2[100];
+	REAL *poly2 = polys[1];
 	int poly2counter = 0;
 	int numpolys;
 	int i;
@@ -3222,6 +3243,7 @@
 // www.mathematik.uni-ulm.de/stochastik/lehre/ws03_04/rt/Geometry2D.ps
 //---------------------------------------------------------------------------------//
 int linePointLocation(REAL x1, REAL y1, REAL x2, REAL y2, REAL x, REAL y){
+	REAL z;
 	if(atan((y2-y1)/(x2-x1))*180.0/PI == 90.0){
 		if(fabs(x1-x) <= 0.00000000001)
 			return 0;
@@ -3230,7 +3252,7 @@
 			return 0;
 	}
 	// third component of the 3 dimensional product
-	REAL z = (x2 - x1) * (y - y1) - (y2 -y1) * (x - x1);
+	z = (x2 - x1) * (y - y1) - (y2 -y1) * (x - x1);
 	if(fabs(z - 0.0) <= 0.00000000001){
 		return 0;
 	}else if(z > 0){
@@ -3296,9 +3318,9 @@
 // Returns the centroid of a given polygon 
 //---------------------------------------------------------------------------------//
 void findPolyCentroid(int numpoints, REAL *points, REAL *centroid){
-	REAL area = 0.0, temp;
-	centroid[0] = 0.0;	centroid[1] = 0.0;
+	REAL area = 0.0;
 	int i;
+	centroid[0] = 0.0;	centroid[1] = 0.0;
 
 	for(i = 0; i < 2*numpoints; i = i+2){
 		
@@ -3309,8 +3331,6 @@
 	centroid[0] = centroid[0]/numpoints;
 	centroid[1] = centroid[1]/numpoints;
 	
-			
-
 }// end of findPolyCentroid()
 
 
@@ -3335,7 +3355,6 @@
 	// This function returns a pointer array which first index indicates
 	// the number of intersection points, followed by coordinate pairs.
 	
-	REAL x , y ;
 	REAL a, b, c, mu, i ;	
 	
 	a =  (x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1);
@@ -3555,12 +3574,13 @@
 /*                                  that it is bad or good                   */
 /*                                                                           */
 /*****************************************************************************/
-
+#ifndef TRILIBRARY
 void writeparts(struct mesh *m, struct behavior *b, int argc, char **argv)
 {
   FILE *outfile;
   struct otri triangleloop;
   vertex p1, p2, p3;
+  REAL minAngleTri, maxAngleTri;
   long elementnumber;
   int i;
   int bad; 
@@ -3576,7 +3596,7 @@
     printf("  Error:  Cannot create file %s.\n", partfilename);
     triexit(1);
   }
-  /* Number of triangles, vertices per triangle, attributes per triangle. */
+  // Number of triangles, vertices per triangle, attributes per triangle.
   fprintf(outfile, "%ld  103\n", m->triangles.items);
 
   traversalinit(&m->triangles);
@@ -3591,11 +3611,11 @@
       // we need to check if this triangle is good or not
       //bad = testTriangleAngleArea(m, b, &p1[0], &p1[1],&p2[0], &p2[1],&p3[0], &p3[1]);
       bad = testTriangleAngle(m, b, &p1[0], &p1[1],&p2[0], &p2[1],&p3[0], &p3[1]);
-      REAL minAngleTri = returnMinAngle(p1[0], p1[1],p2[0], p2[1],p3[0], p3[1]);
-      REAL maxAngleTri = returnMaxAngle(p1[0], p1[1],p2[0], p2[1],p3[0], p3[1]);
+      minAngleTri = returnMinAngle(p1[0], p1[1],p2[0], p2[1],p3[0], p3[1]);
+      maxAngleTri = returnMaxAngle(p1[0], p1[1],p2[0], p2[1],p3[0], p3[1]);
       if(bad){
 	//printf("!!!!!!!!bad >> p1[0]=%f,p1[1]=%f,p2[0]=%f,p2[1]=%f,p3[0]=%f,p3[1]=%f\n", p1[0], p1[1],p2[0], p2[1],p3[0], p3[1]);
-	 /* Triangle number, indices for three vertices. */
+	 // Triangle number, indices for three vertices.
 	if(b->maxangle != 0.00000){
 		fprintf(outfile, "%4ld    %d ", elementnumber,(int)((180.0-maxAngleTri)*0.35+2.0));
 	}else{
@@ -3662,6 +3682,7 @@
 		return angle_p3;
 	}
 }// end of returnMaxAngle()
+#endif
 
 //---------------------------------------------------------------------------------//
 // minDistanceToNeigbor()
@@ -3684,12 +3705,12 @@
 	/* Find a boundary triangle. */
 	/*horiz.tri = m->dummytri;
 	horiz.orient = 0;
-	symself(horiz);	*/	
+	symself(horiz);	*/
 	/* Search for a triangle containing `newvertex'. */
 	/* Start searching from the triangle provided by the caller. */
 	/* Where are we? */
 	org(*searchtri, torg);
-	dest(*searchtri, tdest);	
+	dest(*searchtri, tdest);
 	/* Check the starting triangle's vertices. */
 	if ((torg[0] == newvertex[0]) && (torg[1] == newvertex[1])) {
 		intersect = ONVERTEX;
@@ -3751,7 +3772,7 @@
 /*  Similar to quality_statistics() function, prints a detailed histogram    */
 /*                                                                           */
 /*****************************************************************************/
-
+#ifndef TRILIBRARY
 void detailedHistogram(struct mesh *m, struct behavior *b)
 {
 	struct otri triangleloop;
@@ -3838,6 +3859,7 @@
 	}
 	fclose(outfile);
 }
+#endif
 /*============================NEW CODE ENDS==============================*/
 #endif
 
